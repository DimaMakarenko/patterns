<h1>Singleton</h1>

## v.1 

### **Суть паттерна**
Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

### **Проблема**
Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности класса.

1. **Гарантирует наличие единственного экземпляра класса**. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.

Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.

Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект.

2. **Предоставляет глобальную точку доступа**. Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.

Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.

### **Решение**
Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

### **Структура**
![](/assets/singleton-structure.png)

**Одиночка** определяет статический метод getInstance, который возвращает единственный экземпляр своего класса.

Конструктор одиночки должен быть скрыт от клиентов. Вызов метода getInstance должен стать единственным способом получить объект этого класса.


### **Применимость**

**Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы).**

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

**Когда вам хочется иметь больше контроля над глобальными переменными.**

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса, поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод `getInstance`).

### **Шаги реализации**
1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.

2. Объявите статический создающий метод, который будет использоваться для получения одиночки.

3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.

4. Сделайте конструктор класса приватным.

5. В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.

### **Преимущества и недостатки**
*Преимущества*

 * Гарантирует наличие единственного экземпляра класса.
 * Предоставляет к нему глобальную точку доступа.
 * Реализует отложенную инициализацию объекта-одиночки.
 
 *недостатки*
 * Нарушает принцип единственной ответственности класса.
 * Маскирует плохой дизайн.
 * Проблемы мультипоточности.
 * Требует постоянного создания Mock-объектов при юнит-тестировании.

## v.2
Суть шаблона - обеспечить в приложении наличие только 1 экземпляра определенного класса. Но так как в JS нет классов, то новый объект уже является единственным в приложении. Организовать Singleton можно 2-мя способами: либо использовать литерал объекта (что уже по определению является синглтоном), либо использовать конструктор (который является очень отдаленным примером использования классов в JS).

### Singleton с помощью литерала объекта

```javascript
var obj1 = {
  name: 'test1'
}

var obj2 = {
  name: 'test1'
}

// Сравним адреса ссылок наших объектов
// Строгое сравнение без приведения типов
console.log( obj1 === obj2 ); // false
// Сравнение с приведением типов
console.log( obj1 == obj2 ); // false
```

https://jsfiddle.net/fo0ddn6v/

### Singleton с помощью конструктора
Рассмотрим, как с помощью конструктора можно организовать код, который будет работать по шаблону Singleton.

```javascript
function Sun() {
  // Проверяем наличие экземпляра созданного ранее.
	// Если св-во instance является объектом,
	// это означает, что конструктор ранее запускался.
	// Поэтому надо просто вернуть существующий экземпляр.
	if ( typeof Sun.instance === 'object' ) {
	  return Sun.instance;
	}
	
	// Если Sun.instance === 'undefined',
	// то определяем логику самого конструктора,
	// т.е. инициализируем его свойствами
	// и т.о. создаем новый экземпляр
	this.color = 'yellow';
	this.isBig = true;
	
	// В св-во instance сохраняем ссылку на контекст,
	// т.е. сохраняем созданный экземпляр для повторного использования
	Sun.instance = this;
	
	// Неявный возврат экземпляра
	// return this;
}

var sun1 = new Sun(); // Получаем ссылку на новый экземпляр
// Sun.instance = null;
var sun2 = new Sun(); // Получаем ссылку на существующий экземпляр
console.log(sun1 === sun2); // true - ссылки одинаковые
```

Но у этого шаблона есть недостаток: instance является открытым св-вом конструктора и если мы, например, после первичной инициализации экземпляра вызовем `Sun.instance = null;`, то нарушим работу шаблона. Необходимо инкапсулировать instance.